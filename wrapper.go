package socketcmd
/*	Copyright 2017 Ryan Clarke

	This file is part of socketcmd.

	socketcmd is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	Foobar is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with socketcmd.  If not, see <http://www.gnu.org/licenses/>
*/

import (
	"net"
	"os/exec"
)

/* A Wrapper encapsulates an opaque external process and redirects I/O through a network socket. A client
 * connected to the socket can send commands to the wrapped stdin by writing to the socket and will receive
 * lines of the wrapped stdout based on configurable parsing rules. Connections to the socket are accepted
 * serially to prevent corruption or race conditions.
 */
type Wrapper interface {
	// Run the wrapped process with socket handling. Return any error generated by the process.
	Run() error
	// Start the wrapped process and begin socket handler goroutines.
	Start() error
	// Wait for the wrapped command to finish and cleanup socket handler goroutines.
	Wait() error
}

/* NewWrapper returns a socker wrapper around the given command using the defined protocol and address.
 * If a parsing function is given then it will be used to determine how many lines of stdout to send back.
 */
func NewWrapper(proto, addr string, cmd *exec.Cmd, parsef ParseFunc) (Wrapper, error) {
	ln, err := net.Listen(proto, addr)
	if err != nil {
		return nil, err
	}
	stdin, err := cmd.StdinPipe()
	if err != nil {
		return nil, err
	}
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return nil, err
	}
	return &wrapper{cmd, NewHandler(ln, stdin, stdout, parsef)}, nil
}

type wrapper struct {
	cmd *exec.Cmd
	h   Handler
}

func (wr *wrapper) Start() error {
	if err := wr.cmd.Start(); err != nil {
		return err
	}
	go wr.h.CaptureStdout() // Start stdout scanner
	go wr.h.HandleSocket()  // Start socket handler
	return nil
}

func (wr *wrapper) Wait() error {
	defer wr.h.Close() // Close the listener when finished
	return wr.cmd.Wait()
}

func (wr *wrapper) Run() error {
	if err := wr.Start(); err != nil {
		return err
	}
	return wr.Wait()
}
